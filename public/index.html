<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Threat Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>


  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Poppins', sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      padding: 20px;
    }
   h1 {
  color: #ffd700; /* Ø°Ù‡Ø¨ÙŠ Ù„Ø§Ù…Ø¹ */
  margin-bottom: 20px;
  font-size: 28px;
}

#threatChart {
  height: 250px; /* Ø£Ùˆ Ø£ÙŠ Ù‚ÙŠÙ…Ø© ØªÙ†Ø§Ø³Ø¨Ùƒ Ù…Ø«Ù„ 150px Ø£Ùˆ 250px */
  max-height: 250px;
}


    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    input, select, button {
      background: #161b22;
      color: #ffffff;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 14px;
    }
    .table-container {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #30363d;
      border-radius: 6px;
      margin-bottom: 30px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #30363d;
    }
   th {
  background-color: #222;       /* ØºØ§Ù…Ù‚ Ø£ÙƒØ«Ø± Ù„ÙŠØ¨Ø±Ø² Ø§Ù„Ø°Ù‡Ø¨ */
  color: #ffd700;               /* Ù„ÙˆÙ† Ø°Ù‡Ø¨ÙŠ Ù„Ø§Ù…Ø¹ */
  font-weight: bold;
  font-size: 16px;
}


td {
  color: #ffffff;      /* Ø§Ù„Ù†Øµ Ø£Ø¨ÙŠØ¶ */
  padding: 12px 10px;
  border: 1px solid #333;
  font-size: 15px;
}


    tr:nth-child(even) {
      background-color: #1f2937;
    }

    #threatChart {
      max-width: 100%;
      margin-bottom: 40px;
    }

    form {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button {
      cursor: pointer;
      background-color: #238636;
      color: white;
      transition: background 0.3s;
    }
    button:hover {
      background-color: #2ea043;
    }

    .icon {
      color: #58a6ff;
      margin-right: 5px;
    }

    @media (max-width: 600px) {
      .filters, form {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>

<div style="margin-top: 30px;">
  <h3>Manual Log Analyzer (AI)</h3>
  <input type="text" id="log-input" placeholder="Enter raw log line..." style="width: 60%; padding: 10px;" />
  <button id="generate-btn" style="padding: 10px 15px; background-color:#007bff;">Generate</button>
  <button id="analyze-btn" style="padding: 10px 15px;">Analyze</button>
</div>


<body>

  <h1><i class="fas fa-shield-alt icon"></i> Threat Monitoring Dashboard</h1>

  <div class="filters">
    <input type="text" id="filterIP" placeholder="ğŸ” Filter by IP">
    <select id="filterType">
      <option value="">All Threats</option>
      <option value="malware detected">Malware</option>
      <option value="scan attempt">Scan</option>
      <option value="attack vector">Attack</option>
    </select>
  </div>

  <div class="table-container">
    <table>
      <thead>
        <tr>
          <th>Timestamp</th>
          <th>IP Address</th>
          <th>Method</th>
          <th>Threat Type</th>
          <th>Action Taken</th>

        </tr>
      </thead>
      <tbody id="logTableBody"></tbody>
    </table>
  </div>

  <canvas id="threatChart" height="120"></canvas>

  <h3 style="margin-top: 20px;">Add Fake Threat</h3>
  <form id="addForm">
    <input type="text" name="ip" placeholder="IP" required>
    <select name="method"><option>GET</option><option>POST</option></select>
    <select name="type">
      <option value="malware detected">Malware</option>
      <option value="scan attempt">Scan</option>
      <option value="attack vector">Attack</option>
    </select>
    <button type="submit"><i class="fas fa-plus-circle icon"></i> Add</button>
  </form>

  <script>
    let allLogs = [];
    let chartRef = null;

    async function fetchCSVFromGitHub() {
      const baseUrl = 'https://corsproxy.io/?https://raw.githubusercontent.com/etiqotwf/liveServer1/main/public/logs/threats.csv';
      const nocacheUrl = `${baseUrl}?_=${Date.now()}`;
      try {
        const response = await fetch(nocacheUrl, { cache: "no-store" });
        const text = await response.text();

        if (text.includes('<html') || text.includes('There isn\'t a GitHub Pages site')) return [];

        const rows = text.trim().split('\n').slice(1);
       return rows
  .map(row => row.split(','))
  .filter(parts => parts.length >= 4)  // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
  .map(parts => {
    const [timestamp, ip, method, threatType, action = ''] = parts;
    return { timestamp, ip, method, threatType, action };
  });

      } catch (error) {
        console.error('âŒ Error loading CSV:', error);
        return [];
      }
    }

    function filterLogs(logs) {
      const ipFilter = document.getElementById('filterIP').value.trim();
      const typeFilter = document.getElementById('filterType').value;
      return logs.filter(log =>
        (!ipFilter || log.ip.includes(ipFilter)) &&
        (!typeFilter || log.threatType === typeFilter)
      );
    }

    function renderTable(logs) {
      const tbody = document.getElementById('logTableBody');
      tbody.innerHTML = '';
     logs.forEach(log => {
  const actionDisplay = log.action || 'N/A';
  let color = 'gray';
  if (actionDisplay === 'block') color = 'red';
  else if (actionDisplay === 'alert') color = 'gold';

  document.getElementById('logTableBody').innerHTML += `
   <tr>
  <td>${log.timestamp}</td>
  <td>${log.ip}</td>
  <td>${log.method}</td>
  <td>${log.threatType}</td>
  <td style="font-weight:bold;">
    ${actionIcon(log.action)} ${log.action.toUpperCase()}
  </td>
</tr>

  `;
});

    }

    function drawThreatChart(logs) {
      const filtered = filterLogs(logs);
      const threatCounts = {};
      filtered.forEach(t => {
        threatCounts[t.threatType] = (threatCounts[t.threatType] || 0) + 1;
      });

      const labels = Object.keys(threatCounts);
      const dataValues = Object.values(threatCounts);
      const ctx = document.getElementById('threatChart').getContext('2d');

      if (chartRef) chartRef.destroy();

      chartRef = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Threat Count',
            data: dataValues,
            backgroundColor: ['#d32f2f', '#fbc02d', '#1976d2'],
            borderRadius: 8
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#fff' } },
            title: {
              display: true,
              text: 'Threat Type Statistics',
              color: '#58a6ff'
            }
          },
          scales: {
            x: { ticks: { color: '#ccc' }, grid: { display: false } },
            y: { beginAtZero: true, ticks: { color: '#ccc' }, grid: { color: '#333' } }
          }
        }
      });
    }

    async function updateDashboard() {
      const logs = await fetchCSVFromGitHub();
      allLogs = logs;
      renderTable(filterLogs(allLogs));
      drawThreatChart(allLogs);
    }

    document.getElementById('filterIP').addEventListener('input', () => {
      renderTable(filterLogs(allLogs));
      drawThreatChart(allLogs);
    });

    document.getElementById('filterType').addEventListener('change', () => {
      renderTable(filterLogs(allLogs));
      drawThreatChart(allLogs);
    });

    document.getElementById('addForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const form = e.target;
      const newThreat = {
        ip: form.ip.value,
        method: form.method.value,
        threatType: form.type.value
      };

      const res = await fetch('/api/add-threat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newThreat)
      });

      if (res.ok) {
        form.reset();
        updateDashboard();
      } else {
        alert('âŒ Failed to send threat to server.');
      }
    });

    updateDashboard();


document.addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.error(`Error attempting fullscreen: ${err.message}`);
    });
  }
});



function actionIcon(action) {
  if (!action) return '';
  switch (action.toLowerCase()) {
    case 'blocked':
      return '<span style="color:red;">âŒ</span>';
    case 'suspicious':
    case 'alerted':
      return '<span style="color:orange;">âš ï¸</span>';
    case 'allowed':
    case 'logged':
      return '<span style="color:green;">âœ…</span>';
    default:
      return '<span style="color:gray;">â„¹ï¸</span>'; // Ø±Ù…Ø² Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„Ù…Ø¬Ù‡ÙˆÙ„
  }
}

 const MODEL_URL = './model.json';
  const ACTIONS = ['block', 'alert', 'ignore'];
  const LEARNING_RATE = 0.01;

  function encodeState(log) {
    const ipSuspicion = log.includes('192.168') ? 0 : 1;
    const requestType = log.includes('POST') ? 1 : 0;
    const keywordDetected = /(malware|attack|scan)/i.test(log) ? 1 : 0;
    return [ipSuspicion, requestType, keywordDetected, 0, 0, 0, 0, 0];
  }

  async function loadModel() {
    const model = await tf.loadLayersModel(MODEL_URL);
    model.compile({
      optimizer: tf.train.adam(LEARNING_RATE),
      loss: 'categoricalCrossentropy',
    });
    return model;
  }

  async function selectAction(model, state) {
    const input = tf.tensor2d([state]);
    const prediction = model.predict(input);
    const actionIdx = (await prediction.argMax(1).data())[0];
    return ACTIONS[actionIdx];
  }

  function executeAction(action, log) {
    const line = document.createElement('div');
    const resultBox = document.getElementById('logTableBody');
    switch (action) {
      case 'block':
        line.style.color = 'red';
        line.textContent = `[BLOCKED] ${log}`;
        break;
      case 'alert':
        line.style.color = 'orange';
        line.textContent = `[ALERT] ${log}`;
        break;
      default:
        line.style.color = 'gray';
        line.textContent = `[IGNORED] ${log}`;
    }
    resultBox.appendChild(line);
  }

  document.getElementById('analyze-btn')?.addEventListener('click', async () => {
    const logInput = document.getElementById('log-input')?.value.trim();
    if (!logInput) return;
    const model = await loadModel();
    analyzeLog(logInput, model);
  });

  async function analyzeLog(log, model) {
    const state = encodeState(log);
    const action = await selectAction(model, state);
    executeAction(action, log);
  }



  // ØªÙˆÙ„ÙŠØ¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„Ù‡Ø¬Ù…Ø§Øª
const ATTACK_TYPES = [
  { type: 'malware detected', methods: ['POST', 'GET'], keywords: ['Trojan.exe', 'virus_payload', 'malicious.exe'] },
  { type: 'scan attempt', methods: ['GET'], keywords: ['nmap scan', 'port scan', 'banner grab'] },
  { type: 'attack vector', methods: ['POST'], keywords: ['SQL injection', 'XSS payload', 'buffer overflow'] }
];

function getRandomIP() {
  return `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
}

function generateRandomLog() {
  const attack = ATTACK_TYPES[Math.floor(Math.random() * ATTACK_TYPES.length)];
  const ip = getRandomIP();
  const method = attack.methods[Math.floor(Math.random() * attack.methods.length)];
  const keyword = attack.keywords[Math.floor(Math.random() * attack.keywords.length)];
  const threatType = attack.type;
  const timestamp = new Date().toISOString();

  return {
    timestamp,
    ip,
    method,
    threatType,
    keyword,
    raw: `${timestamp} ${ip} ${method} ${threatType} ${keyword}`
  };
}

// Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Generate
document.getElementById('generate-btn').addEventListener('click', async () => {
  const log = generateRandomLog();
  document.getElementById('log-input').value = log.raw;

  const model = await loadModel();
  const state = encodeState(log.raw);
  const action = await selectAction(model, state);

  // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ø§Ù„Ù„ÙˆØ¬ ÙˆØªØ­Ù„ÙŠÙ„Ù‡
  const analyzedLog = {
    timestamp: log.timestamp,
    ip: log.ip,
    method: log.method,
    threatType: log.threatType,
    action
  };

  // Ø£Ø¶Ù ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¬Ø¯ÙˆÙ„
  prependLogToTable(analyzedLog);

  // Ø­Ø¯Ù‘Ø« Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ
  allLogs.unshift(analyzedLog); // Ø£Ø¶Ù ÙÙŠ Ø£ÙˆÙ„ Ù‚Ø§Ø¦Ù…Ø© allLogs
  drawThreatChart(allLogs);
});

// Ø¥Ø¶Ø§ÙØ© ØµÙ ÙÙŠ Ø£ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙˆÙ„
function prependLogToTable(log) {
  const tbody = document.getElementById('logTableBody');
  const newRow = document.createElement('tr');
  newRow.innerHTML = `
    <td>${log.timestamp}</td>
    <td>${log.ip}</td>
    <td>${log.method}</td>
    <td>${log.threatType}</td>
    <td style="font-weight:bold;">${actionIcon(log.action)} ${log.action.toUpperCase()}</td>
  `;
  tbody.prepend(newRow);
}

  </script>
</body>
</html>
